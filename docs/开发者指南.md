# pymd 分子动力学模拟器 - 开发者指南

## 目录

1. [架构概述](#架构概述)
2. [设计模式](#设计模式)
3. [扩展指南](#扩展指南)
4. [API参考](#api参考)
5. [测试](#测试)
6. [GUI 桌面应用架构](#gui-桌面应用架构)

---

## 架构概述

### 模块结构

```
src/pymd/
├── core/           # 核心数据结构
│   ├── atom.py         # Atom类
│   ├── state.py        # State数据类
│   ├── system.py       # System容器类
│   ├── units.py        # 单位系统
│   └── element_registry.py  # 元素周期表
│
├── boundary/       # 边界条件（策略模式）
│   ├── boundary_condition.py  # ABC
│   ├── periodic_bc.py
│   ├── open_bc.py
│   └── mixed_bc.py
│
├── neighbor/       # 邻居列表算法
│   ├── neighbor_list.py    # ABC
│   ├── brute_force.py
│   ├── verlet_list.py
│   └── cell_list.py
│
├── potential/      # 势能函数
│   ├── potential_energy.py  # ABC
│   ├── lennard_jones.py
│   ├── morse.py
│   └── eam.py
│
├── force/          # 力计算
│   ├── autodiff_backend.py  # 自动微分后端
│   └── force_calculator.py
│
├── integrator/     # 时间积分
│   ├── integrator.py     # ABC
│   └── velocity_verlet.py
│
├── minimizer/      # 能量最小化（模板方法模式）
│   ├── minimizer.py       # ABC + MinimizationResult
│   ├── steepest_descent.py
│   ├── conjugate_gradient.py
│   └── lbfgs.py
│
├── thermostat/     # 恒温器
│   ├── thermostat.py     # ABC
│   ├── no_thermostat.py
│   ├── berendsen.py
│   └── nose_hoover.py
│
├── observer/       # 观察者模式
│   └── observer.py
│
├── simulator/      # 模拟器
│   └── simulator.py
│
├── builder/        # 构建器
│   ├── system_builder.py
│   └── config_loader.py
│
└── gui/            # 桌面 GUI（pywebview + 3Dmol.js）
    ├── main.py          # 入口：创建 pywebview 窗口
    ├── api.py           # SimulatorAPI，JS 与 Python 桥梁
    └── assets/
        ├── index.html       # 单页应用
        ├── styles.css       # 样式
        ├── app.js           # 前端逻辑
        └── 3Dmol-min.js     # 3Dmol.js 本地副本
```

---

## 设计模式

### 1. 策略模式 (Strategy Pattern)

边界条件、势能函数、恒温器等均采用策略模式，可自由替换：

```python
# 抽象基类定义接口
class BoundaryCondition(ABC):
    @abstractmethod
    def wrap_positions(self, positions, box):
        pass

# 具体策略实现
class PeriodicBoundaryCondition(BoundaryCondition):
    def wrap_positions(self, positions, box):
        return positions % box
```

### 2. 模板方法模式 (Template Method Pattern)

`Minimizer`的`minimize()`方法定义了收敛循环的骨架，子类通过`_step()`提供具体算法：

```python
class Minimizer(ABC):
    def minimize(self, system, force_calculator):
        # 模板：初始化 → 循环(_step → 检查收敛) → 归零速度 → 返回结果
        ...

    @abstractmethod
    def _step(self, system, force_calculator, forces, energy):
        # 子类实现具体的最小化步骤
        pass
```

### 3. 建造者模式 (Builder Pattern)

`SystemBuilder`和`SimulatorBuilder`使用流式API：

```python
system = (
    SystemBuilder()
    .element("Ar", 1.0)
    .fcc_lattice(4, 4, 4, 1.5)
    .temperature(0.8)
    .build()
)
```

### 4. 观察者模式 (Observer Pattern)

模拟过程中通过观察者记录数据：

```python
class EnergyObserver(Observer):
    def observe(self, system, step, potential_energy):
        self.energies.append(potential_energy)
```

---

## 扩展指南

### 添加新势能函数

1. 继承`PotentialEnergy`基类
2. 实现`compute_energy()`方法

```python
from pymd.potential import PotentialEnergy

class MyPotential(PotentialEnergy):
    """自定义势能函数"""
    
    def __init__(self, param1: float, cutoff: float = 5.0):
        super().__init__(cutoff=cutoff)
        self.param1 = param1
    
    def compute_energy(
        self,
        positions: np.ndarray,
        box: np.ndarray,
        atom_types: np.ndarray,
    ) -> float:
        """
        计算总势能。
        
        Args:
            positions: (N, 3) 原子位置
            box: (3,) 盒子尺寸
            atom_types: (N,) 原子类型索引
            
        Returns:
            总势能（标量）
        """
        energy = 0.0
        # 实现你的势能计算逻辑
        # ...
        return energy
    
    def get_name(self) -> str:
        return f"MyPotential(param1={self.param1})"
```

### 添加新积分器

继承`Integrator`基类，实现`step()`方法：

```python
from pymd.integrator import Integrator

class LeapfrogIntegrator(Integrator):
    """蛙跳积分器"""
    
    def step(self, system, force_calculator) -> float:
        dt = self.dt
        state = system.state
        masses = system.get_masses()
        
        # 1. 更新速度半步
        accelerations = state.forces / masses[:, np.newaxis]
        state.velocities += 0.5 * accelerations * dt
        
        # 2. 更新位置
        state.positions += state.velocities * dt
        system.wrap_positions()
        
        # 3. 计算新力
        forces, pe = force_calculator.compute_forces_and_energy(system)
        state.forces = forces
        
        # 4. 更新速度半步
        accelerations = forces / masses[:, np.newaxis]
        state.velocities += 0.5 * accelerations * dt
        
        state.time += dt
        state.step += 1
        return pe
    
    def get_name(self) -> str:
        return f"Leapfrog(dt={self.dt})"
```

### 添加新恒温器

```python
from pymd.thermostat import Thermostat

class VelocityRescaleThermostat(Thermostat):
    """简单速度缩放恒温器"""

    def apply(self, system, dt):
        current_T = system.compute_temperature()
        if current_T < 1e-10:
            return
        scale = np.sqrt(self.target_temperature / current_T)
        system.state.velocities *= scale

    def get_name(self):
        return f"VelocityRescale(T={self.target_temperature})"
```

### 添加新最小化算法

`Minimizer` ABC采用**模板方法模式**：`minimize()` 是具体方法，负责收敛循环；子类只需实现 `_step()` 和可选的 `_initialize()`。

```python
import numpy as np
from pymd.minimizer import Minimizer

class FireMinimizer(Minimizer):
    """FIRE（Fast Inertial Relaxation Engine）最小化器"""

    def __init__(
        self,
        force_tol: float = 1e-4,
        energy_tol: float = 1e-8,
        max_steps: int = 10000,
        dt_start: float = 0.01,
    ):
        super().__init__(force_tol=force_tol, energy_tol=energy_tol, max_steps=max_steps)
        self._dt = dt_start

    def _initialize(self, system, forces, energy):
        """算法初始化（在收敛循环之前调用一次）"""
        self._velocity = np.zeros_like(forces)

    def _step(self, system, force_calculator, forces, energy):
        """
        执行一步最小化。

        必须：
        1. 更新 system.state.positions
        2. 调用 system.wrap_positions()
        3. 返回 (new_forces, new_energy)
        """
        # 实现FIRE算法的单步更新
        # ...

        system.state.positions += self._dt * self._velocity
        system.wrap_positions()

        new_forces, new_energy = force_calculator.compute_forces_and_energy(system)
        return new_forces, new_energy

    def get_name(self) -> str:
        return f"FIRE(force_tol={self.force_tol})"
```

**关键点：**
- 继承 `Minimizer` ABC
- 实现 `_step(system, force_calculator, forces, energy) -> (new_forces, new_energy)`
- 实现 `get_name() -> str`
- 可选：覆盖 `_initialize(system, forces, energy)` 进行初始设置
- `_step()` 中必须更新 `system.state.positions` 并调用 `system.wrap_positions()`
- 不需要管理收敛循环、速度归零、结果返回——这些由 `minimize()` 模板方法处理

---

## API参考

### 核心类

#### `System`

```python
class System:
    atoms: List[Atom]          # 原子列表
    state: State               # 当前状态
    boundary_condition: BC     # 边界条件
    units: UnitSystem          # 单位系统
    
    def get_num_atoms(self) -> int
    def get_masses(self) -> np.ndarray
    def get_box(self) -> np.ndarray
    def compute_kinetic_energy(self) -> float
    def compute_temperature(self) -> float
    def wrap_positions(self) -> None
```

#### `State`

```python
@dataclass
class State:
    positions: np.ndarray   # (N, 3)
    velocities: np.ndarray  # (N, 3)
    forces: np.ndarray      # (N, 3)
    box: np.ndarray         # (3,)
    time: float = 0.0
    step: int = 0
```

#### `ForceCalculator`

```python
class ForceCalculator:
    def compute_forces(self, system) -> np.ndarray
    def compute_forces_and_energy(self, system) -> Tuple[np.ndarray, float]
```

#### `Minimizer`

```python
class Minimizer(ABC):
    def __init__(self, force_tol=1e-4, energy_tol=1e-8, max_steps=10000)
    def minimize(self, system, force_calculator) -> MinimizationResult  # 模板方法
    def _step(self, system, force_calculator, forces, energy) -> tuple  # 抽象：子类实现
    def _initialize(self, system, forces, energy) -> None               # 可选覆盖
    def get_name(self) -> str                                           # 抽象
```

#### `MinimizationResult`

```python
@dataclass
class MinimizationResult:
    converged: bool           # 是否收敛
    n_steps: int              # 迭代步数
    initial_energy: float     # 初始能量
    final_energy: float       # 最终能量
    max_force: float          # 最终最大力分量
    energy_history: List[float]  # 每步能量
    message: str              # 结果描述
```

#### `Simulator`

```python
class Simulator:
    def initialize(self) -> None
    def run(self, num_steps: int) -> None
    def get_total_steps(self) -> int
```

---

## 测试

### 运行测试

```bash
# 运行所有单元测试
python -m pytest tests/unit/ -v

# 运行特定模块测试
python -m pytest tests/unit/test_potential.py -v

# 运行带覆盖率
python -m pytest tests/unit/ --cov=pymd
```

### 测试结构

```
tests/
├── unit/
│   ├── test_core.py       # 核心模块测试
│   ├── test_boundary.py   # 边界条件测试
│   ├── test_neighbor.py   # 邻居列表测试
│   ├── test_potential.py  # 势能函数测试
│   ├── test_force.py      # 力计算测试
│   ├── test_integrator.py # 积分器测试
│   ├── test_minimizer.py  # 最小化器测试
│   ├── test_thermostat.py # 恒温器测试
│   ├── test_simulator.py  # 模拟器测试
│   └── test_builder.py    # 构建器测试
└── debug_autodiff.py      # 自动微分验证
```

### 当前测试状态

- **192个测试通过**
- 覆盖所有主要模块（含最小化器44个测试）

---

## GUI 桌面应用架构

pymd 提供了一个基于 pywebview + 3Dmol.js 的桌面 GUI，位于 `src/pymd/gui/` 目录。GUI 是 pymd 核心库之上的独立层，不修改任何 pymd 模块。

### 目录结构

```
src/pymd/gui/
├── main.py              # 入口：创建 pywebview 窗口，绑定 API
├── api.py               # SimulatorAPI 类，通过 js_api 暴露给 JavaScript
└── assets/
    ├── index.html       # 单页应用（5 个标签页）
    ├── styles.css       # 所有样式
    ├── app.js           # 前端逻辑：表单处理、API 调用、Canvas 图表
    └── 3Dmol-min.js     # 3Dmol.js 本地副本（无 CDN 依赖）
```

### SimulatorAPI 类

`src/pymd/gui/api.py` 中的 `SimulatorAPI` 是前端与 pymd 之间的桥梁：

```python
class SimulatorAPI:
    def load_yaml(self)           # 打开文件对话框，解析 YAML，返回配置
    def build_system(self, config) # 构建 System + ForceCalculator
    def get_xyz(self)             # 获取当前原子位置的 XYZ 字符串
    def start_simulation(self, ...)  # 后台线程运行模拟
    def stop_simulation(self)     # 停止模拟
    def get_energy_data(self)     # 获取 EnergyObserver 数据
    def run_minimization(self, ...) # 后台线程运行最小化
```

所有方法通过 JSON 字符串与前端通信（参数和返回值均为 JSON）。

### 线程模型

- `start_simulation()` 和 `run_minimization()` 创建 `threading.Thread(daemon=True)`
- 后台线程通过 `window.evaluate_js()` 推送实时数据（能量 + XYZ 坐标）
- `stop_simulation()` 设置 `self.running = False`，后台线程每次循环检查该标志
- pymd 对象仅在后台线程中访问，避免并发问题

### 3Dmol.js 集成

XYZ 格式由 `_system_to_xyz()` 从 `system.state.positions` + `atom.atom_type` 生成：

```
256
Step 100
Ar  0.000000  0.000000  0.000000
Ar  1.200000  0.000000  0.000000
...
```

JavaScript 端的 `updateViewer(xyzString)` 函数通过 Python 的 `evaluate_js()` 调用：
1. `viewer.removeAllModels()` — 清除旧模型
2. `viewer.addModel(xyz, "xyz")` — 加载新坐标
3. `viewer.setStyle({}, {sphere: {scale: 0.3}})` — 设置渲染样式
4. `viewer.zoomTo()` → `viewer.render()` — 刷新视图

### 扩展 GUI

**添加新标签页：**
1. 在 `index.html` 中添加 `<section id="tab-xxx" class="tab-panel">` 和对应的导航项
2. 在 `app.js` 中添加标签页交互逻辑
3. 在 `api.py` 的 `SimulatorAPI` 中添加需要的后端方法

**添加新 API 方法：**
1. 在 `SimulatorAPI` 中添加方法（返回 JSON 字符串）
2. 前端通过 `await pywebview.api.method_name(args)` 调用
3. 长时间运行的任务应使用后台线程 + `evaluate_js()` 推送进度

---

## 性能说明

### 数值后端限制

当前使用数值微分计算力，复杂度为O(N×3)次势能求值。对于大系统较慢。

### 优化建议

1. **小系统测试**：先用少量原子验证正确性
2. **解析力**：实现`compute_pair_force()`方法可绕过数值微分
3. **JAX后端**：需要势能函数使用`jax.numpy`重写

---

## 作者

本软件由 **Prof. Bin Shan (单斌教授)** 开发。
联系邮箱：stanfordbshan@gmail.com

---

*pymd开发团队*
