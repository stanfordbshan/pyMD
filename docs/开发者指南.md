# pyMD 分子动力学模拟器 - 开发者指南

## 目录

1. [架构概述](#架构概述)
2. [设计模式](#设计模式)
3. [扩展指南](#扩展指南)
4. [API参考](#api参考)
5. [测试](#测试)

---

## 架构概述

### 模块结构

```
md_simulator/
├── core/           # 核心数据结构
│   ├── atom.py         # Atom类
│   ├── state.py        # State数据类
│   ├── system.py       # System容器类
│   ├── units.py        # 单位系统
│   └── element_registry.py  # 元素周期表
│
├── boundary/       # 边界条件（策略模式）
│   ├── boundary_condition.py  # ABC
│   ├── periodic_bc.py
│   ├── open_bc.py
│   └── mixed_bc.py
│
├── neighbor/       # 邻居列表算法
│   ├── neighbor_list.py    # ABC
│   ├── brute_force.py
│   ├── verlet_list.py
│   └── cell_list.py
│
├── potential/      # 势能函数
│   ├── potential_energy.py  # ABC
│   ├── lennard_jones.py
│   ├── morse.py
│   └── eam.py
│
├── force/          # 力计算
│   ├── autodiff_backend.py  # 自动微分后端
│   └── force_calculator.py
│
├── integrator/     # 时间积分
│   ├── integrator.py     # ABC
│   └── velocity_verlet.py
│
├── thermostat/     # 恒温器
│   ├── thermostat.py     # ABC
│   ├── no_thermostat.py
│   ├── berendsen.py
│   └── nose_hoover.py
│
├── observer/       # 观察者模式
│   └── observer.py
│
├── simulator/      # 模拟器
│   └── simulator.py
│
└── builder/        # 构建器
    ├── system_builder.py
    └── config_loader.py
```

---

## 设计模式

### 1. 策略模式 (Strategy Pattern)

边界条件、势能函数、恒温器等均采用策略模式，可自由替换：

```python
# 抽象基类定义接口
class BoundaryCondition(ABC):
    @abstractmethod
    def wrap_positions(self, positions, box):
        pass

# 具体策略实现
class PeriodicBoundaryCondition(BoundaryCondition):
    def wrap_positions(self, positions, box):
        return positions % box
```

### 2. 建造者模式 (Builder Pattern)

`SystemBuilder`和`SimulatorBuilder`使用流式API：

```python
system = (
    SystemBuilder()
    .element("Ar", 1.0)
    .fcc_lattice(4, 4, 4, 1.5)
    .temperature(0.8)
    .build()
)
```

### 3. 观察者模式 (Observer Pattern)

模拟过程中通过观察者记录数据：

```python
class EnergyObserver(Observer):
    def observe(self, system, step, potential_energy):
        self.energies.append(potential_energy)
```

---

## 扩展指南

### 添加新势能函数

1. 继承`PotentialEnergy`基类
2. 实现`compute_energy()`方法

```python
from md_simulator.potential import PotentialEnergy

class MyPotential(PotentialEnergy):
    """自定义势能函数"""
    
    def __init__(self, param1: float, cutoff: float = 5.0):
        super().__init__(cutoff=cutoff)
        self.param1 = param1
    
    def compute_energy(
        self,
        positions: np.ndarray,
        box: np.ndarray,
        atom_types: np.ndarray,
    ) -> float:
        """
        计算总势能。
        
        Args:
            positions: (N, 3) 原子位置
            box: (3,) 盒子尺寸
            atom_types: (N,) 原子类型索引
            
        Returns:
            总势能（标量）
        """
        energy = 0.0
        # 实现你的势能计算逻辑
        # ...
        return energy
    
    def get_name(self) -> str:
        return f"MyPotential(param1={self.param1})"
```

### 添加新积分器

继承`Integrator`基类，实现`step()`方法：

```python
from md_simulator.integrator import Integrator

class LeapfrogIntegrator(Integrator):
    """蛙跳积分器"""
    
    def step(self, system, force_calculator) -> float:
        dt = self.dt
        state = system.state
        masses = system.get_masses()
        
        # 1. 更新速度半步
        accelerations = state.forces / masses[:, np.newaxis]
        state.velocities += 0.5 * accelerations * dt
        
        # 2. 更新位置
        state.positions += state.velocities * dt
        system.wrap_positions()
        
        # 3. 计算新力
        forces, pe = force_calculator.compute_forces_and_energy(system)
        state.forces = forces
        
        # 4. 更新速度半步
        accelerations = forces / masses[:, np.newaxis]
        state.velocities += 0.5 * accelerations * dt
        
        state.time += dt
        state.step += 1
        return pe
    
    def get_name(self) -> str:
        return f"Leapfrog(dt={self.dt})"
```

### 添加新恒温器

```python
from md_simulator.thermostat import Thermostat

class VelocityRescaleThermostat(Thermostat):
    """简单速度缩放恒温器"""
    
    def apply(self, system, dt):
        current_T = system.compute_temperature()
        if current_T < 1e-10:
            return
        scale = np.sqrt(self.target_temperature / current_T)
        system.state.velocities *= scale
    
    def get_name(self):
        return f"VelocityRescale(T={self.target_temperature})"
```

---

## API参考

### 核心类

#### `System`

```python
class System:
    atoms: List[Atom]          # 原子列表
    state: State               # 当前状态
    boundary_condition: BC     # 边界条件
    units: UnitSystem          # 单位系统
    
    def get_num_atoms(self) -> int
    def get_masses(self) -> np.ndarray
    def get_box(self) -> np.ndarray
    def compute_kinetic_energy(self) -> float
    def compute_temperature(self) -> float
    def wrap_positions(self) -> None
```

#### `State`

```python
@dataclass
class State:
    positions: np.ndarray   # (N, 3)
    velocities: np.ndarray  # (N, 3)
    forces: np.ndarray      # (N, 3)
    box: np.ndarray         # (3,)
    time: float = 0.0
    step: int = 0
```

#### `ForceCalculator`

```python
class ForceCalculator:
    def compute_forces(self, system) -> np.ndarray
    def compute_forces_and_energy(self, system) -> Tuple[np.ndarray, float]
```

#### `Simulator`

```python
class Simulator:
    def initialize(self) -> None
    def run(self, num_steps: int) -> None
    def get_total_steps(self) -> int
```

---

## 测试

### 运行测试

```bash
# 运行所有单元测试
python -m pytest tests/unit/ -v

# 运行特定模块测试
python -m pytest tests/unit/test_potential.py -v

# 运行带覆盖率
python -m pytest tests/unit/ --cov=md_simulator
```

### 测试结构

```
tests/
├── unit/
│   ├── test_core.py       # 核心模块测试
│   ├── test_boundary.py   # 边界条件测试
│   ├── test_neighbor.py   # 邻居列表测试
│   ├── test_potential.py  # 势能函数测试
│   ├── test_force.py      # 力计算测试
│   ├── test_integrator.py # 积分器测试
│   ├── test_thermostat.py # 恒温器测试
│   ├── test_simulator.py  # 模拟器测试
│   └── test_builder.py    # 构建器测试
└── debug_autodiff.py      # 自动微分验证
```

### 当前测试状态

- **148个测试通过**
- 覆盖所有主要模块

---

## 性能说明

### 数值后端限制

当前使用数值微分计算力，复杂度为O(N×3)次势能求值。对于大系统较慢。

### 优化建议

1. **小系统测试**：先用少量原子验证正确性
2. **解析力**：实现`compute_pair_force()`方法可绕过数值微分
3. **JAX后端**：需要势能函数使用`jax.numpy`重写

---

## 作者

本软件由 **Prof. Bin Shan (单斌教授)** 开发。
联系邮箱：bshan@mail.hust.edu.cn

---

*pyMD开发团队*
