# pyMD 分子动力学模拟器 - 用户手册

## 目录

1. [简介](#简介)
2. [安装](#安装)
3. [快速开始](#快速开始)
4. [核心概念](#核心概念)
5. [构建系统](#构建系统)
6. [势能函数](#势能函数)
7. [积分器与恒温器](#积分器与恒温器)
8. [能量最小化](#能量最小化)
9. [运行模拟](#运行模拟)
10. [YAML配置](#yaml配置)
11. [示例](#示例)

---

## 简介

pyMD是一个用Python编写的分子动力学(MD)模拟框架。它采用模块化设计，支持多种势能函数、积分算法和恒温器，适合教学和研究使用。

### 主要特性

- **模块化架构**：策略模式设计，组件可自由组合
- **多种势能函数**：Lennard-Jones、Morse、EAM等
- **自动微分求力**：支持数值微分后端
- **能量最小化**：最陡下降法、共轭梯度法、L-BFGS算法
- **晶格生成器**：FCC、BCC、SC晶格自动构建
- **YAML配置**：通过配置文件设置模拟参数

---

## 安装

### 环境要求

- Python 3.10+
- NumPy

### 安装步骤

```bash
# 克隆仓库
git clone https://github.com/stanfordbshan/pyMD.git
cd pyMD

# 安装依赖
pip install numpy

# 可选：安装PyYAML用于配置文件
pip install pyyaml

# 运行测试
python -m pytest tests/unit/ -q

### 使用Conda/Mamba安装（推荐）

如果您使用Anaconda或Miniconda，可以通过`environment.yml`文件快速创建环境：

```bash
# 创建名为pymd的环境
conda env create -f environment.yml

# 激活环境
conda activate pymd

# 验证安装
python -m pytest tests/unit/ -q
```
```

---

## 快速开始

### 最简示例：2原子LJ模拟

```python
import numpy as np
from pyMD.core import Atom, State, System, Units
from pyMD.boundary import PeriodicBoundaryCondition
from pyMD.force import ForceCalculator, NumericalBackend
from pyMD.integrator import VelocityVerlet
from pyMD.potential import LennardJonesPotential
from pyMD.simulator import Simulator
from pyMD.thermostat import NoThermostat

# 1. 创建原子
atoms = [Atom(mass=1.0, atom_type="Ar"), Atom(mass=1.0, atom_type="Ar")]

# 2. 设置状态（位置、速度、盒子）
state = State(
    positions=np.array([[0.0, 0.0, 0.0], [1.2, 0.0, 0.0]]),
    velocities=np.array([[-0.1, 0.0, 0.0], [0.1, 0.0, 0.0]]),
    forces=np.zeros((2, 3)),
    box=np.array([10.0, 10.0, 10.0]),
)

# 3. 创建系统
system = System(
    atoms=atoms,
    state=state,
    boundary_condition=PeriodicBoundaryCondition(),
    units=Units.LJ(),
)

# 4. 设置势能和力计算器
potential = LennardJonesPotential(epsilon=1.0, sigma=1.0, cutoff=2.5)
force_calc = ForceCalculator(potential=potential, backend=NumericalBackend())

# 5. 创建并运行模拟器
sim = Simulator(
    system=system,
    integrator=VelocityVerlet(dt=0.005),
    force_calculator=force_calc,
    thermostat=NoThermostat(),
)
sim.run(num_steps=100)

print(f"最终温度: {system.compute_temperature():.4f}")
```

---

## 核心概念

### 单位系统

pyMD支持多种单位系统：

| 单位系统 | 长度 | 能量 | 时间 | 质量 |
|---------|------|------|------|------|
| `Units.LJ()` | σ | ε | τ=σ√(m/ε) | m |
| `Units.REAL()` | Å | kcal/mol | fs | g/mol |
| `Units.METAL()` | Å | eV | ps | g/mol |
| `Units.SI()` | m | J | s | kg |

### 边界条件

```python
from pyMD.boundary import (
    PeriodicBoundaryCondition,  # 周期性边界
    OpenBoundaryCondition,       # 开放边界
    MixedBoundaryCondition,      # 混合边界
)

# 混合边界：x和y方向周期性，z方向开放
bc = MixedBoundaryCondition(periodic_dims=(True, True, False))
```

---

## 构建系统

### 使用SystemBuilder

`SystemBuilder`提供流式API构建晶格系统：

```python
from pyMD.builder import SystemBuilder
from pyMD.core import Units

# FCC晶格
system = (
    SystemBuilder()
    .element("Ar", mass=39.948)        # 设置元素
    .fcc_lattice(nx=4, ny=4, nz=4, a=5.26)  # 4x4x4 FCC
    .temperature(100.0)                 # 初始温度
    .units(Units.REAL())               # REAL单位
    .periodic_boundary()               # 周期性边界
    .build()
)

print(f"原子数: {system.get_num_atoms()}")  # 256
```

### 晶格类型

| 方法 | 晶格类型 | 每晶胞原子数 |
|------|---------|------------|
| `.fcc_lattice()` | 面心立方 | 4 |
| `.bcc_lattice()` | 体心立方 | 2 |
| `.sc_lattice()` | 简单立方 | 1 |
| `.random_positions()` | 随机分布 | N |

---

## 势能函数

### Lennard-Jones势

适用于惰性气体（Ar、Kr等）：

```python
from pyMD.potential import LennardJonesPotential

# U(r) = 4ε[(σ/r)^12 - (σ/r)^6]
potential = LennardJonesPotential(
    epsilon=1.0,   # 势阱深度
    sigma=1.0,     # 零势能距离
    cutoff=2.5,    # 截断半径（单位：σ）
)
```

### Morse势

适用于化学键：

```python
from pyMD.potential import MorsePotential

# U(r) = D[1 - exp(-a(r-r0))]^2
potential = MorsePotential(
    D=1.0,     # 解离能
    a=1.0,     # 势阱宽度
    r0=1.0,    # 平衡键长
    cutoff=5.0,
)
```

### 组合势

```python
from pyMD.potential import CompositePotential

composite = CompositePotential([lj_potential, morse_potential])
```

---

## 积分器与恒温器

### 积分器

**Velocity Verlet**（推荐）：
```python
from pyMD.integrator import VelocityVerlet

integrator = VelocityVerlet(dt=0.005)  # 时间步长
```

### 恒温器

| 恒温器 | 系综 | 用途 |
|--------|------|------|
| `NoThermostat()` | NVE | 能量守恒测试 |
| `BerendsenThermostat()` | 弱NVT | 快速平衡 |
| `NoseHooverThermostat()` | NVT | 正确正则系综 |

```python
from pyMD.thermostat import (
    NoThermostat,
    BerendsenThermostat,
    NoseHooverThermostat,
)

# NVE（无恒温器）
thermostat = NoThermostat()

# Berendsen（快速平衡）
thermostat = BerendsenThermostat(
    target_temperature=1.0,
    tau=0.5,  # 耦合时间常数
)

# Nose-Hoover（正规NVT）
thermostat = NoseHooverThermostat(
    target_temperature=1.0,
    tau=0.5,
)
```

---

## 能量最小化

pyMD提供了三种能量最小化算法，用于在MD模拟前优化原子构型（寻找势能面的局部极小值）。最小化器是独立模块，不依赖模拟器或积分器。

### 可用算法

| 算法 | 类名 | 特点 |
|------|------|------|
| 最陡下降法 | `SteepestDescent` | 最简单，适合初步优化 |
| 共轭梯度法 | `ConjugateGradient` | 默认推荐，收敛速度快于SD |
| L-BFGS | `LBFGS` | 拟牛顿法，近极小值附近效率最高 |

### 基本用法

```python
from pyMD.minimizer import ConjugateGradient

# 创建最小化器
minimizer = ConjugateGradient(
    force_tol=1e-4,    # 力收敛阈值（最大力分量）
    energy_tol=1e-8,   # 能量收敛阈值
    max_steps=10000,   # 最大迭代步数
)

# 执行最小化（system和force_calc已创建）
result = minimizer.minimize(system, force_calc)

# 查看结果
print(f"收敛: {result.converged}")
print(f"步数: {result.n_steps}")
print(f"初始能量: {result.initial_energy:.6f}")
print(f"最终能量: {result.final_energy:.6f}")
print(f"最大力: {result.max_force:.2e}")
```

### 收敛判据

最小化在满足以下任一条件时停止：

1. **力收敛**（主要）：所有力分量的最大绝对值 < `force_tol`
2. **能量收敛**（次要）：相邻两步能量变化 < `energy_tol`
3. **步数上限**：达到 `max_steps`（此时 `result.converged = False`）

### 各算法参数

**SteepestDescent：**
```python
from pyMD.minimizer import SteepestDescent

sd = SteepestDescent(
    force_tol=1e-4,
    initial_step_size=0.01,  # 初始步长
    max_step_size=0.1,       # 最大步长
)
```

**ConjugateGradient（推荐）：**
```python
from pyMD.minimizer import ConjugateGradient

cg = ConjugateGradient(
    force_tol=1e-4,
    initial_step_size=0.01,
    max_step_size=0.1,
    restart_interval=0,  # 0表示自动（3*原子数）
)
```

**LBFGS：**
```python
from pyMD.minimizer import LBFGS

lbfgs = LBFGS(
    force_tol=1e-4,
    memory=10,               # 存储的校正对数量
    initial_step_size=0.01,
    max_step_size=0.1,
)
```

### 典型工作流：最小化 + MD模拟

```python
from pyMD.minimizer import ConjugateGradient
from pyMD.simulator import Simulator

# 1. 先最小化构型
minimizer = ConjugateGradient(force_tol=1e-4)
result = minimizer.minimize(system, force_calc)
print(f"最小化完成: {result.message}")

# 2. 然后运行MD模拟
sim = Simulator(
    system=system,  # 已最小化的system
    integrator=integrator,
    force_calculator=force_calc,
    thermostat=thermostat,
)
sim.run(num_steps=5000)
```

### MinimizationResult 字段

| 字段 | 类型 | 说明 |
|------|------|------|
| `converged` | `bool` | 是否收敛 |
| `n_steps` | `int` | 迭代步数 |
| `initial_energy` | `float` | 最小化前能量 |
| `final_energy` | `float` | 最小化后能量 |
| `max_force` | `float` | 最终构型的最大力分量 |
| `energy_history` | `List[float]` | 每步能量记录 |
| `message` | `str` | 结果描述 |

---

## 运行模拟

### 基本模拟

```python
from pyMD.simulator import Simulator
from pyMD.observer import EnergyObserver, PrintObserver

# 创建观察者
energy_obs = EnergyObserver(interval=100)
print_obs = PrintObserver(interval=500)

# 创建模拟器
sim = Simulator(
    system=system,
    integrator=integrator,
    force_calculator=force_calc,
    thermostat=thermostat,
    observers=[energy_obs, print_obs],
)

# 运行5000步
sim.run(num_steps=5000)

# 分析结果
print(f"能量漂移: {energy_obs.get_energy_drift():.2e}")
```

### 使用Builder模式

```python
from pyMD.simulator import SimulatorBuilder

sim = (
    SimulatorBuilder()
    .with_system(system)
    .with_integrator(VelocityVerlet(dt=0.005))
    .with_force_calculator(force_calc)
    .with_thermostat(BerendsenThermostat(1.0, 0.5))
    .add_observer(EnergyObserver())
    .build()
)
```

---

## YAML配置

### 配置文件示例

```yaml
# lj_argon.yaml
units: LJ

system:
  element: Ar
  mass: 1.0
  lattice:
    type: fcc
    nx: 4
    ny: 4
    nz: 4
    a: 1.5
  temperature: 0.8

boundary:
  type: periodic

potential:
  type: lj
  epsilon: 1.0
  sigma: 1.0
  cutoff: 2.5

integrator:
  dt: 0.005

thermostat:
  type: berendsen
  temperature: 0.8
  tau: 0.5

run:
  steps: 5000
```

### 加载并运行

```python
from pyMD.builder import load_and_run

sim = load_and_run("lj_argon.yaml")
```

---

## 示例

### 示例1：NVE能量守恒测试

```bash
python examples/quick_test.py
```

### 示例2：LJ氩气液体模拟

```bash
python examples/run_lj_argon.py
```

---

## 常见问题

### Q: 模拟运行很慢？

A: 数值微分后端较慢。对于大系统，建议减少原子数或步数进行测试。

### Q: 能量漂移很大？

A: 尝试减小时间步长（dt）。典型值：LJ单位下 dt=0.001~0.005。

### Q: 如何添加新势能函数？

A: 继承`PotentialEnergy`基类，实现`compute_energy()`方法。详见开发者文档。

---

## 作者与联系方式

pyMD由 **Prof. Bin Shan (单斌教授)** 开发。
联系邮箱：bshan@mail.hust.edu.cn

---

*pyMD - 简洁高效的分子动力学模拟框架*
