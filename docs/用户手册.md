# pymd 分子动力学模拟器 - 用户手册

## 目录

1. [简介](#简介)
2. [安装](#安装)
3. [快速开始](#快速开始)
4. [核心概念](#核心概念)
5. [构建系统](#构建系统)
6. [势能函数](#势能函数)
7. [积分器与恒温器](#积分器与恒温器)
8. [能量最小化](#能量最小化)
9. [运行模拟](#运行模拟)
10. [YAML配置](#yaml配置)
11. [示例](#示例)
12. [桌面应用 (GUI)](#桌面应用-gui)

---

## 简介

pymd是一个用Python编写的分子动力学(MD)模拟框架。它采用模块化设计，支持多种势能函数、积分算法和恒温器，适合教学和研究使用。

### 主要特性

- **模块化架构**：策略模式设计，组件可自由组合
- **多种势能函数**：Lennard-Jones、Morse、EAM等
- **自动微分求力**：支持数值微分后端
- **能量最小化**：最陡下降法、共轭梯度法、L-BFGS算法
- **晶格生成器**：FCC、BCC、SC晶格自动构建
- **YAML配置**：通过配置文件设置模拟参数

---

## 安装

### 环境要求

- Python 3.10+
- NumPy

### 安装步骤

```bash
# 克隆仓库
git clone https://github.com/stanfordbshan/pymd.git
cd pymd

# 安装依赖
pip install numpy

# 可选：安装PyYAML用于配置文件
pip install pyyaml

# 运行测试
python -m pytest tests/unit/ -q

### 使用Conda/Mamba安装（推荐）

如果您使用Anaconda或Miniconda，可以通过`environment.yml`文件快速创建环境：

```bash
# 创建名为pymd的环境
conda env create -f environment.yml

# 激活环境
conda activate pymd

# 验证安装
python -m pytest tests/unit/ -q
```
```

---

## 快速开始

### 最简示例：2原子LJ模拟

```python
import numpy as np
from pymd.core import Atom, State, System, Units
from pymd.boundary import PeriodicBoundaryCondition
from pymd.force import ForceCalculator, NumericalBackend
from pymd.integrator import VelocityVerlet
from pymd.potential import LennardJonesPotential
from pymd.simulator import Simulator
from pymd.thermostat import NoThermostat

# 1. 创建原子
atoms = [Atom(mass=1.0, atom_type="Ar"), Atom(mass=1.0, atom_type="Ar")]

# 2. 设置状态（位置、速度、盒子）
state = State(
    positions=np.array([[0.0, 0.0, 0.0], [1.2, 0.0, 0.0]]),
    velocities=np.array([[-0.1, 0.0, 0.0], [0.1, 0.0, 0.0]]),
    forces=np.zeros((2, 3)),
    box=np.array([10.0, 10.0, 10.0]),
)

# 3. 创建系统
system = System(
    atoms=atoms,
    state=state,
    boundary_condition=PeriodicBoundaryCondition(),
    units=Units.LJ(),
)

# 4. 设置势能和力计算器
potential = LennardJonesPotential(epsilon=1.0, sigma=1.0, cutoff=2.5)
force_calc = ForceCalculator(potential=potential, backend=NumericalBackend())

# 5. 创建并运行模拟器
sim = Simulator(
    system=system,
    integrator=VelocityVerlet(dt=0.005),
    force_calculator=force_calc,
    thermostat=NoThermostat(),
)
sim.run(num_steps=100)

print(f"最终温度: {system.compute_temperature():.4f}")
```

---

## 核心概念

### 单位系统

pymd支持多种单位系统：

| 单位系统 | 长度 | 能量 | 时间 | 质量 |
|---------|------|------|------|------|
| `Units.LJ()` | σ | ε | τ=σ√(m/ε) | m |
| `Units.REAL()` | Å | kcal/mol | fs | g/mol |
| `Units.METAL()` | Å | eV | ps | g/mol |
| `Units.SI()` | m | J | s | kg |

### 边界条件

```python
from pymd.boundary import (
    PeriodicBoundaryCondition,  # 周期性边界
    OpenBoundaryCondition,       # 开放边界
    MixedBoundaryCondition,      # 混合边界
)

# 混合边界：x和y方向周期性，z方向开放
bc = MixedBoundaryCondition(periodic_dims=(True, True, False))
```

---

## 构建系统

### 使用SystemBuilder

`SystemBuilder`提供流式API构建晶格系统：

```python
from pymd.builder import SystemBuilder
from pymd.core import Units

# FCC晶格
system = (
    SystemBuilder()
    .element("Ar", mass=39.948)        # 设置元素
    .fcc_lattice(nx=4, ny=4, nz=4, a=5.26)  # 4x4x4 FCC
    .temperature(100.0)                 # 初始温度
    .units(Units.REAL())               # REAL单位
    .periodic_boundary()               # 周期性边界
    .build()
)

print(f"原子数: {system.get_num_atoms()}")  # 256
```

### 晶格类型

| 方法 | 晶格类型 | 每晶胞原子数 |
|------|---------|------------|
| `.fcc_lattice()` | 面心立方 | 4 |
| `.bcc_lattice()` | 体心立方 | 2 |
| `.sc_lattice()` | 简单立方 | 1 |
| `.random_positions()` | 随机分布 | N |

---

## 势能函数

### Lennard-Jones势

适用于惰性气体（Ar、Kr等）：

```python
from pymd.potential import LennardJonesPotential

# U(r) = 4ε[(σ/r)^12 - (σ/r)^6]
potential = LennardJonesPotential(
    epsilon=1.0,   # 势阱深度
    sigma=1.0,     # 零势能距离
    cutoff=2.5,    # 截断半径（单位：σ）
)
```

### Morse势

适用于化学键：

```python
from pymd.potential import MorsePotential

# U(r) = D[1 - exp(-a(r-r0))]^2
potential = MorsePotential(
    D=1.0,     # 解离能
    a=1.0,     # 势阱宽度
    r0=1.0,    # 平衡键长
    cutoff=5.0,
)
```

### 组合势

```python
from pymd.potential import CompositePotential

composite = CompositePotential([lj_potential, morse_potential])
```

---

## 积分器与恒温器

### 积分器

**Velocity Verlet**（推荐）：
```python
from pymd.integrator import VelocityVerlet

integrator = VelocityVerlet(dt=0.005)  # 时间步长
```

### 恒温器

| 恒温器 | 系综 | 用途 |
|--------|------|------|
| `NoThermostat()` | NVE | 能量守恒测试 |
| `BerendsenThermostat()` | 弱NVT | 快速平衡 |
| `NoseHooverThermostat()` | NVT | 正确正则系综 |

```python
from pymd.thermostat import (
    NoThermostat,
    BerendsenThermostat,
    NoseHooverThermostat,
)

# NVE（无恒温器）
thermostat = NoThermostat()

# Berendsen（快速平衡）
thermostat = BerendsenThermostat(
    target_temperature=1.0,
    tau=0.5,  # 耦合时间常数
)

# Nose-Hoover（正规NVT）
thermostat = NoseHooverThermostat(
    target_temperature=1.0,
    tau=0.5,
)
```

---

## 能量最小化

pymd提供了三种能量最小化算法，用于在MD模拟前优化原子构型（寻找势能面的局部极小值）。最小化器是独立模块，不依赖模拟器或积分器。

### 可用算法

| 算法 | 类名 | 特点 |
|------|------|------|
| 最陡下降法 | `SteepestDescent` | 最简单，适合初步优化 |
| 共轭梯度法 | `ConjugateGradient` | 默认推荐，收敛速度快于SD |
| L-BFGS | `LBFGS` | 拟牛顿法，近极小值附近效率最高 |

### 基本用法

```python
from pymd.minimizer import ConjugateGradient

# 创建最小化器
minimizer = ConjugateGradient(
    force_tol=1e-4,    # 力收敛阈值（最大力分量）
    energy_tol=1e-8,   # 能量收敛阈值
    max_steps=10000,   # 最大迭代步数
)

# 执行最小化（system和force_calc已创建）
result = minimizer.minimize(system, force_calc)

# 查看结果
print(f"收敛: {result.converged}")
print(f"步数: {result.n_steps}")
print(f"初始能量: {result.initial_energy:.6f}")
print(f"最终能量: {result.final_energy:.6f}")
print(f"最大力: {result.max_force:.2e}")
```

### 收敛判据

最小化在满足以下任一条件时停止：

1. **力收敛**（主要）：所有力分量的最大绝对值 < `force_tol`
2. **能量收敛**（次要）：相邻两步能量变化 < `energy_tol`
3. **步数上限**：达到 `max_steps`（此时 `result.converged = False`）

### 各算法参数

**SteepestDescent：**
```python
from pymd.minimizer import SteepestDescent

sd = SteepestDescent(
    force_tol=1e-4,
    initial_step_size=0.01,  # 初始步长
    max_step_size=0.1,       # 最大步长
)
```

**ConjugateGradient（推荐）：**
```python
from pymd.minimizer import ConjugateGradient

cg = ConjugateGradient(
    force_tol=1e-4,
    initial_step_size=0.01,
    max_step_size=0.1,
    restart_interval=0,  # 0表示自动（3*原子数）
)
```

**LBFGS：**
```python
from pymd.minimizer import LBFGS

lbfgs = LBFGS(
    force_tol=1e-4,
    memory=10,               # 存储的校正对数量
    initial_step_size=0.01,
    max_step_size=0.1,
)
```

### 典型工作流：最小化 + MD模拟

```python
from pymd.minimizer import ConjugateGradient
from pymd.simulator import Simulator

# 1. 先最小化构型
minimizer = ConjugateGradient(force_tol=1e-4)
result = minimizer.minimize(system, force_calc)
print(f"最小化完成: {result.message}")

# 2. 然后运行MD模拟
sim = Simulator(
    system=system,  # 已最小化的system
    integrator=integrator,
    force_calculator=force_calc,
    thermostat=thermostat,
)
sim.run(num_steps=5000)
```

### MinimizationResult 字段

| 字段 | 类型 | 说明 |
|------|------|------|
| `converged` | `bool` | 是否收敛 |
| `n_steps` | `int` | 迭代步数 |
| `initial_energy` | `float` | 最小化前能量 |
| `final_energy` | `float` | 最小化后能量 |
| `max_force` | `float` | 最终构型的最大力分量 |
| `energy_history` | `List[float]` | 每步能量记录 |
| `message` | `str` | 结果描述 |

---

## 运行模拟

### 基本模拟

```python
from pymd.simulator import Simulator
from pymd.observer import EnergyObserver, PrintObserver

# 创建观察者
energy_obs = EnergyObserver(interval=100)
print_obs = PrintObserver(interval=500)

# 创建模拟器
sim = Simulator(
    system=system,
    integrator=integrator,
    force_calculator=force_calc,
    thermostat=thermostat,
    observers=[energy_obs, print_obs],
)

# 运行5000步
sim.run(num_steps=5000)

# 分析结果
print(f"能量漂移: {energy_obs.get_energy_drift():.2e}")
```

### 使用Builder模式

```python
from pymd.simulator import SimulatorBuilder

sim = (
    SimulatorBuilder()
    .with_system(system)
    .with_integrator(VelocityVerlet(dt=0.005))
    .with_force_calculator(force_calc)
    .with_thermostat(BerendsenThermostat(1.0, 0.5))
    .add_observer(EnergyObserver())
    .build()
)
```

---

## YAML配置

### 配置文件示例

```yaml
# lj_argon.yaml
units: LJ

system:
  element: Ar
  mass: 1.0
  lattice:
    type: fcc
    nx: 4
    ny: 4
    nz: 4
    a: 1.5
  temperature: 0.8

boundary:
  type: periodic

potential:
  type: lj
  epsilon: 1.0
  sigma: 1.0
  cutoff: 2.5

integrator:
  dt: 0.005

thermostat:
  type: berendsen
  temperature: 0.8
  tau: 0.5

run:
  steps: 5000
```

### 加载并运行

```python
from pymd.builder import load_and_run

sim = load_and_run("lj_argon.yaml")
```

---

## 示例

### 示例1：NVE能量守恒测试

```bash
python examples/quick_test.py
```

### 示例2：LJ氩气液体模拟

```bash
python examples/run_lj_argon.py
```

---

## 桌面应用 (GUI)

pymd 提供了基于 pywebview 的桌面图形界面，集成 3Dmol.js 三维分子可视化，支持系统配置、模拟运行、能量最小化和结果分析。

> **注意**：GUI 是独立的可选模块，pymd 核心库和命令行用法不受影响。

### 安装

```bash
# 安装 pywebview 依赖
pip install pywebview

# 或通过可选依赖安装
pip install -e ".[gui]"
```

### 启动

```bash
python -m pymd.gui.main
```

启动后会打开 1200×800 的桌面窗口。

### 界面概览

应用包含左侧导航栏和五个功能标签页：

#### 1. Setup（系统设置）

配置模拟参数，对应 YAML 配置结构：

- **Units**：选择单位系统（LJ / REAL / METAL / SI）
- **System**：元素、质量、晶格类型（FCC/BCC/SC/Random）、晶格参数、初始温度
- **Boundary**：边界条件（周期性 / 开放 / 混合）
- **Potential**：势能类型（Lennard-Jones / Morse）及参数
- **Integrator**：时间步长 dt
- **Thermostat**：恒温器类型（NVE / Berendsen / Nose-Hoover）、目标温度、耦合常数
- **Observers**：能量记录间隔

操作按钮：
- **Load YAML**：打开系统文件对话框，加载 YAML 配置文件并自动填充所有字段
- **Build System**：根据当前参数构建 pymd 系统，显示摘要信息

#### 2. Visualization（三维可视化）

- 使用 3Dmol.js 渲染原子结构，支持鼠标拖拽旋转、滚轮缩放
- 在 Build System、模拟运行和最小化后自动更新
- 原子按元素着色（Jmol 配色方案）
- **Reset View** 按钮重置视角

#### 3. Simulation（模拟运行）

- 设置模拟步数和可视化更新间隔
- **Start / Stop** 按钮控制模拟
- 实时显示：进度条、当前步数、温度、势能（PE）、动能（KE）、总能量
- Canvas 绘制实时能量图（PE、KE、Total vs Step）
- 3D 视图按设定间隔更新原子位置

#### 4. Minimization（能量最小化）

- 选择算法：Steepest Descent / Conjugate Gradient / L-BFGS
- 设置参数：力容差、能量容差、最大步数
- 显示结果：是否收敛、迭代步数、初始/最终能量、最大力
- Canvas 绘制能量历史曲线

#### 5. Results（结果汇总）

- 显示最近模拟和最小化的统计数据
- 能量漂移、最终温度等
- **Copy Energy Data** 按钮将能量数据复制到剪贴板

### 典型工作流

1. 启动应用：`python -m pymd.gui.main`
2. **Setup** 标签页：点击 **Load YAML** 加载 `examples/lj_argon.yaml`（或手动填写参数）
3. 点击 **Build System** → 3D 视图显示 256 个 Ar 原子
4. 切换到 **Simulation** 标签页 → 设置 2000 步 → 点击 **Start**
5. 观察实时能量图和原子运动动画
6. 切换到 **Minimization** 标签页 → 选择 L-BFGS → 点击 **Minimize**
7. 切换到 **Results** 标签页查看汇总数据，点击 **Copy** 导出

---

## 常见问题

### Q: 模拟运行很慢？

A: 数值微分后端较慢。对于大系统，建议减少原子数或步数进行测试。

### Q: 能量漂移很大？

A: 尝试减小时间步长（dt）。典型值：LJ单位下 dt=0.001~0.005。

### Q: 如何添加新势能函数？

A: 继承`PotentialEnergy`基类，实现`compute_energy()`方法。详见开发者文档。

---

## 作者与联系方式

pymd由 **Prof. Bin Shan (单斌教授)** 开发。
联系邮箱：bshan@mail.hust.edu.cn

---

*pymd - 简洁高效的分子动力学模拟框架*
